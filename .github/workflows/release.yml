name: Build and Release

on:
  push:
    tags:
      - 'v*.*.*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., 1.3.9)'
        required: true
        type: string

permissions:
  contents: write

jobs:
  build-and-release:
    name: Build and Release PHTV
    runs-on: macos-latest
    outputs:
      version: ${{ steps.version.outputs.version }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: latest-stable

      - name: Get version
        id: version
        run: |
          if [ -n "${{ github.event.inputs.version }}" ]; then
            VERSION="${{ github.event.inputs.version }}"
          elif [ -n "${{ github.ref_name }}" ]; then
            VERSION="${{ github.ref_name }}"
            VERSION="${VERSION#v}"
          else
            VERSION=$(/usr/libexec/PlistBuddy -c "Print CFBundleShortVersionString" PHTV/Info.plist)
          fi
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Building version: $VERSION"

      - name: Update version in Info.plist
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          
          # Backup original
          cp PHTV/Info.plist PHTV/Info.plist.bak
          
          # Update CFBundleShortVersionString
          /usr/libexec/PlistBuddy -c "Set :CFBundleShortVersionString $VERSION" PHTV/Info.plist
          
          # Auto increment CFBundleVersion (build number)
          CURRENT_BUILD=$(/usr/libexec/PlistBuddy -c "Print CFBundleVersion" PHTV/Info.plist)
          NEW_BUILD=$((CURRENT_BUILD + 1))
          /usr/libexec/PlistBuddy -c "Set :CFBundleVersion $NEW_BUILD" PHTV/Info.plist
          
          echo "✓ Updated Info.plist:"
          echo "  CFBundleShortVersionString: $VERSION"
          echo "  CFBundleVersion: $NEW_BUILD (was $CURRENT_BUILD)"

      - name: Build PHTV (full log)
        run: |
          set -eo pipefail
          VERSION="${{ steps.version.outputs.version }}"
          echo "Building PHTV version $VERSION..."
          
          xcodebuild \
            -project PHTV.xcodeproj \
            -scheme PHTV \
            -configuration Release \
            -destination 'platform=macOS' \
            -derivedDataPath ./build \
            CODE_SIGN_IDENTITY="-" \
            CODE_SIGNING_REQUIRED=NO \
            CODE_SIGNING_ALLOWED=NO \
            clean build \
            | tee /tmp/xcodebuild.log

          # Upload log on success too (helps debugging post-run)
          cp /tmp/xcodebuild.log ./xcodebuild.log
          
          if [ ! -d "./build/Build/Products/Release/PHTV.app" ]; then
            echo "❌ Build failed - PHTV.app not found"
            exit 1
          fi
          
          echo "✓ Build completed successfully"

      - name: Create DMG with Applications shortcut
        if: ${{ success() }}
        id: create_dmg
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          APP_PATH="./build/Build/Products/Release/PHTV.app"
          DMG_NAME="PHTV-$VERSION.dmg"
          DMG_PATH="./$DMG_NAME"
          VOLUME_NAME="PHTV"
          
          # Create temporary directory for DMG contents
          TEMP_DIR=$(mktemp -d)
          echo "Creating DMG contents in $TEMP_DIR"
          
          # Copy app
          cp -R "$APP_PATH" "$TEMP_DIR/"
          
          # Create Applications symlink
          ln -s /Applications "$TEMP_DIR/Applications"
          
          echo "✓ DMG contents ready (app + Applications symlink)"
          
          # Create DMG
          hdiutil create -volname "$VOLUME_NAME" \
                         -srcfolder "$TEMP_DIR" \
                         -ov \
                         -format UDZO \
                         -imagekey zlib-level=9 \
                         "$DMG_PATH"
          
          # Clean up
          rm -rf "$TEMP_DIR"
          
          # Get file info
          FILE_SIZE=$(stat -f%z "$DMG_PATH")
          SIZE_MB=$(echo "scale=2; $FILE_SIZE/1024/1024" | bc)
          
          echo "✓ DMG created: $DMG_PATH"
          echo "  Size: $FILE_SIZE bytes ($SIZE_MB MB)"
          echo "dmg_path=$DMG_PATH" >> $GITHUB_OUTPUT
          echo "dmg_name=$DMG_NAME" >> $GITHUB_OUTPUT

      - name: Download Sparkle tools
        if: ${{ success() }}
        id: sparkle
        run: |
          SPARKLE_DIR="/tmp/Sparkle-for-Swift-Package-Manager"
          
          if [ -d "$SPARKLE_DIR" ]; then
            echo "✓ Sparkle already downloaded"
          else
            echo "Downloading Sparkle..."
            cd /tmp
            curl -LO https://github.com/sparkle-project/Sparkle/releases/latest/download/Sparkle-for-Swift-Package-Manager.zip
            unzip -q Sparkle-for-Swift-Package-Manager.zip
            echo "✓ Sparkle downloaded"
          fi
          
          echo "sparkle_bin=$SPARKLE_DIR/bin" >> $GITHUB_OUTPUT

      - name: Sign update with Sparkle
        if: ${{ success() && env.SPARKLE_PRIVATE_KEY != '' }}
        id: sign_update
        env:
          SPARKLE_PRIVATE_KEY: ${{ secrets.SPARKLE_PRIVATE_KEY }}
        run: |
          DMG_PATH="${{ steps.create_dmg.outputs.dmg_path }}"
          SPARKLE_BIN="${{ steps.sparkle.outputs.sparkle_bin }}"
          
          # Create temp key file
          echo "$SPARKLE_PRIVATE_KEY" > /tmp/sparkle_key
          
          # Sign the update
          SIGNATURE=$("$SPARKLE_BIN/sign_update" "$DMG_PATH" -f /tmp/sparkle_key | grep 'sparkle:edSignature=' | cut -d'"' -f2)
          rm /tmp/sparkle_key
          
          echo "✓ Update signed with Sparkle"
          echo "signature=$SIGNATURE" >> $GITHUB_OUTPUT

      - name: Create release with GitHub
        if: ${{ success() }}
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ steps.version.outputs.version }}
          name: PHTV ${{ steps.version.outputs.version }}
          files: ${{ steps.create_dmg.outputs.dmg_path }}
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Update appcast feed
        if: ${{ success() }}
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          DMG_NAME="${{ steps.create_dmg.outputs.dmg_name }}"
          SIGNATURE="${{ steps.sign_update.outputs.signature }}"
          DMG_PATH="${{ steps.create_dmg.outputs.dmg_path }}"
          
          FILE_SIZE=$(stat -f%z "$DMG_PATH")
          DOWNLOAD_URL="https://github.com/${{ github.repository }}/releases/download/v$VERSION/$DMG_NAME"
          DATE=$(date -u +"%a, %d %b %Y %H:%M:%S %z")
          
          # Create appcast entry
          cat > /tmp/appcast_entry.xml << EOF
          <item>
              <title>Version $VERSION</title>
              <link>https://github.com/${{ github.repository }}/releases/tag/v$VERSION</link>
              <sparkle:version>$VERSION</sparkle:version>
              <sparkle:shortVersionString>$VERSION</sparkle:shortVersionString>
              <description><![CDATA[
                  <h2>PHTV $VERSION</h2>
                  <p>See release notes at: <a href="https://github.com/${{ github.repository }}/releases/tag/v$VERSION">GitHub Release</a></p>
              ]]></description>
              <pubDate>$DATE</pubDate>
              <enclosure url="$DOWNLOAD_URL"
                         sparkle:version="$VERSION"
                         sparkle:shortVersionString="$VERSION"
                         length="$FILE_SIZE"
                         type="application/octet-stream"
          EOF
          
          if [ -n "$SIGNATURE" ]; then
            echo "           sparkle:edSignature=\"$SIGNATURE\"" >> /tmp/appcast_entry.xml
          fi
          
          echo "           />" >> /tmp/appcast_entry.xml
          echo "      </item>" >> /tmp/appcast_entry.xml
          
          echo "✓ Appcast entry created"

      - name: Checkout main and update appcast
        if: ${{ success() }}
        uses: actions/checkout@v4
        with:
          ref: main
          path: repo-main

      - name: Merge appcast entry into feed
        if: ${{ success() }}
        run: |
          FEED_PATH="repo-main/docs/appcast.xml"
          ENTRY_PATH="/tmp/appcast_entry.xml"
          TEMP_FEED="/tmp/appcast_merged.xml"
          
          if [ ! -f "$FEED_PATH" ]; then
            echo "Error: appcast.xml not found"
            exit 1
          fi
          if [ ! -f "$ENTRY_PATH" ]; then
            echo "Error: appcast entry not found"
            exit 1
          fi
          
          # Simple XML merge: extract channel, insert entry at position 8 (after <description>)
          # Insert new item after the opening <channel> tag
          sed -e '/<channel>/a\' "$ENTRY_PATH" "$FEED_PATH" > "$TEMP_FEED"
          
          # Replace original
          mv "$TEMP_FEED" "$FEED_PATH"
          echo "✓ Appcast merged"

      - name: Commit and push appcast
        if: ${{ success() }}
        run: |
          cd repo-main
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add docs/appcast.xml
          
          if git diff --cached --quiet; then
            echo "No changes to appcast"
          else
            git commit -m "chore: update appcast for v${{ steps.version.outputs.version }}"
            git push
            echo "✓ Appcast updated and pushed"
          fi

      - name: Upload build log
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: xcodebuild-log
          path: xcodebuild.log

  update-homebrew:
    name: Update Homebrew Formula
    runs-on: macos-latest
    needs: build-and-release
    if: success()

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: main

      - name: Download DMG
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION="${{ needs.build-and-release.outputs.version }}"
          mkdir -p Releases/$VERSION
          
          gh release download "v$VERSION" \
            --pattern "PHTV-$VERSION.dmg" \
            --dir "Releases/$VERSION"
          
          echo "✓ DMG downloaded"

      - name: Calculate SHA256
        id: sha
        run: |
          VERSION="${{ needs.build-and-release.outputs.version }}"
          DMG_PATH="Releases/$VERSION/PHTV-$VERSION.dmg"
          SHA256=$(shasum -a 256 "$DMG_PATH" | awk '{print $1}')
          echo "sha256=$SHA256" >> $GITHUB_OUTPUT

      - name: Update Homebrew formula
        run: |
          VERSION="${{ needs.build-and-release.outputs.version }}"
          SHA256="${{ steps.sha.outputs.sha256 }}"
          
          # Update version and sha256
          sed -i '' "s/version \".*/version \"$VERSION\"/" homebrew/phtv.rb
          sed -i '' "s/sha256 \".*/sha256 \"$SHA256\"/" homebrew/phtv.rb
          
          echo "✓ Updated homebrew/phtv.rb"

      - name: Commit and push formula
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add homebrew/phtv.rb
          
          if git diff --cached --quiet; then
            echo "No changes to formula"
          else
            git commit -m "chore: bump Homebrew formula to v${{ needs.build-and-release.outputs.version }}"
            git push
            echo "✓ Homebrew formula updated"
          fi
